# 참조 자료형 캐스팅(reference Type casting)
- 객체 지향 프로그래밍(OOP)에서 중요한 요소 중 하나
## 사전 지식
- Java 상에서의 자료형은 크게 두 가지로 구분됨.
    1. 기본 자료형(Primitive Type): int, double, char, float, long
    2. 참조 자료형(Reference Type): 객체를 참조하는 변수로, 클래스나 인터페이스로 생성된 객체
- 참조 자료형 캐스팅이란? - 객체의 자료형을 변환하는 작음.
- int -> double / int - long으로 변형하는 것은 형변환(conversion)이라고 함

## 캐스팅 종류
1. Upcasting : 하위 클래스 타입의 객체를 상위 클래스 타입으로 변환
2. Downcasting : 상위 클래스 타입의 객체를 하위 클래스 타입으로 변환

## 미리 기억해두셔야 할 연산자(Operator) : instanceof
ex : 1 + 1 = 2 에서 +가 연산자 / = 대입 연산자인 것처럼,
ex : 객체명 instanceof 클래스명 -> return true / false

## Upcasting
- 암시적(Implicit)으로 이루어짐
  - 알아서 바뀐다. 근데 언제 알아서 바뀌었는지는 개발자가 알고 잇어야함.

## Downcasting
- 명시적(explicit)으로 이루어짐
  - 반드시 개발자가 적절한 장소와 시간대에 사용하야 하ㄴ다.

## 업캐스팅과 다운캐스팅의 활용
- 캐스팅은 다형성(Polymorphism)을 구현할 때 사용. 상위 클래스 타입으로 객체를 처리하면서도 특정 상황에서는 하위 클래스의 고유 기능을 사용가능
# 장단점
- 장점 :
  - 코드 유연성 : 업캐스팅을 통해 '다양한 객체를 하나의 상위 클래스 타입으로 관리' 가능
  - 댜형성 구현 : 메서드 오버라이딩과 함께 사용하면 코드의 재사용성 ↑
- 단점 :
  - 다운캐스팅의 위험성 : 잘못 다운캐스팅을 하게 될 수 있음.
    - 상위 클래스 Aㅇ와 하위 클래스 B, C가 있다고 가정할 때, B의 객체인 b를 A로 업캐스팅한 후에 C로 다운캐스팅을 하려고 시도하면 컴파일링 오류 발생.
  - 복잡성 증가 : 코드 가독성이 떨어질 수 있음.
    - 이렇게 바꿨다가 저렇게 바꿨다가 하기 때문인데 특히 업캐스팅의 경우 암시적으로 일어나기 때문에 어디서 이루어졌는지 왔인 못하고 있다가 갑자기 명시적으로
      작성하는 다운 캐스팅이 튀어나와서 초심자들이 코드 읽는게 어려워지는 경우가 발생할 수 잇습니다.
      이상의 문제들을 해결하기 위한 연산자가 -> instanceof 입니다.
    코드 예시
```java
public static void main(String[] args) {
    System.out.println(objectA instanceof ClassA); // 결과값 true /
    // false
}
// objectA: 검사하려는 객체명
// ClassA: 객체가 검사될 클래스 / 이넡페이스
```

- return 값은 objectA가 ClassA의 인스턴스이거나 '하위' 클래스의 인스턴스인 경우 true 아니면 false

window + e 눌러서 -> 아무런 숨김 파일이 없다는 것을 확인
git init
git config user.name "깃허브아이디"
git config user.email "깃허브 이메일"
git config user.name
git config user.email

새로운 깃허브리포지토리에 올리는 방법만 했는데
git remote add origin https://github.com/raedered/korit_07_java.git

git add
git commit -m "feat: 20250808 자리 이동후"
git push -u origin main

했는데 실패하면
git push -u origin main --force


# 📦 Java 코드 문서화

## 📄 Animal.java

```java
package ch15_casting.animals;

public class Animal {
    public void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

```

## 📄 Dog.java

```java
package ch15_casting.animals;

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("개가 짖습니다.");
    }

    public void fetch() {
        System.out.println("강아지가 공을 물어옵니다.");
    }
}

```

## 📄 Main.java

```java
package ch15_casting.animals;

public class Main {
    public static void main(String[] args) {
        Dog dog1 = new Dog();
        dog1.makeSound();
        dog1.fetch();

        Animal animal1 = dog1; // 업캐스팅 # 1
        animal1.makeSound();    // 결과값 : 강아지가 공을 물어옵니다. 즉 재정의된 method가 호출됨.
//        animal1.fetch(); // 이게 불가능
        Animal animal2 = new Dog();  // 이게 A a = new B(); 형태입니다..시헝에 자주 나옴

        animal2.makeSound();    // 결과값 : 개가 짖습니다.
//        animal2.fetch();        // 불가능
        /*
            클래스A 객채명 = new 클래스B();를 통해 객체를 생성했을 경우
            1. Override가 적용된 메서드, 즉 자식 클래스의 메서드가 호출됨.
            2. 클래스B(자식 클래스)의 고유 메서드는 호출 불가능.

            그럼 어차피 재정의된 method 버전으로 호출리 될거라면 에초에
            클래스B 객체명 = new 클래스B(); 로 생성해버리면 재정의된 method도 호출되고 고유 method도
            호출할 수 있으니가 골치 아픈거 아니냐
         */

        Animal animal3 = new Animal();
        animal3.makeSound();    // 결과값 : 동물이 소리를 냅니다.

        // 연산자 instanceof 사용 사례
        boolean result1 = animal1 instanceof Animal;
        System.out.println(result1);        // true
        boolean result2 = animal2 instanceof  Dog;
        System.out.println(result2);

        // : 업캐스팅이 이루어지지 않고 그냥 Dog dog1 = new Dog()로 반든 객채 역시
        boolean result3 = animal3 instanceof  Animal;   // true
        System.out.println(result3);
        boolean result4 = animal2 instanceof  Dog;
        System.out.println(result4);    //true

        // animal3의 경우 Animal animal3 = new Animal();로 생성했습니다.
        boolean result5 = animal3 instanceof Animal;
        System.out.println(result5);    //true
        boolean result6 = animal3 instanceof Dog;
        System.out.println(result6);    // false

        System.out.println("↑ 업캐스팅 파트 - 객체명.메서드명(); 했을 때 재정의버전이 나오는가 아닌가에 주목");
        System.out.println("↓ 다운캐스팅 파트");
        /*
            다운캐스팅은 '명시적'으로 이루어져야 합니다.
            방법
            (클래스명)객체명; -> (int)2.3; 과 같은 방식이죠, conversion의 객체 버젼이라고 생각하시면 됩니다.
            그래서 기본 자료형의 형변환에서 벗어나서 참조 자료형까지 고려하셔야 합니다.
         */

        Dog dog2 = (Dog)animal2;
        // 다운캐스팅 방법 -> 위에 보시면 Animal animal2 = new Dog();으로 생성해서 dog2 객체명은 없습니다.
        dog2.makeSound();   // 결과값 : 개가 짖습니다.
        dog2.fetch();
        // dog2로 새로운 객체명을 선언하고 거기에 명시적 참조 자료형 캐스팅을 적용하여 Animal 클래스의
        // 인스턴스인 animal2를 downcasting했습니다.
        // 그 결과 원래도 되던 재정의 버젼의 makeSound(); 호출은 변함이 없고,
        // Dog 클래스의 고유 메서드인 fetch();도 호출리 가능합니다.
        //여전히 B b = new B();로 생성하면 귀찮을 일 없지 않냐는 의문이 존재합니다.

//        Dog dog3 = (Dog) animal3; // downcasting을 하는 과정에서 오류가 발생함.
//        dog3.makeSound();         // 그러니까 얘는 지금 호출도 못해보는 상황입니다.
        /*
            74번 라인에서 오류가 방생했습니다.
            즉 애초에 animal3를 생성할 때 Animal 클래스의 생성자를 호출해서 만들었기 때문에
            (A a = new A();이기 때문에)
            하위 클래스의 인스턴스로 다운캐스팅하는 것이 불가능합니다.

            이상을 해결하기 위해서는
         */
        Animal animal4 = new Dog();
        // 형태로 선언된 클래스와 호출되는 생성자가 서로 달라야 합니다.(그리고 둘은 상속관계여야합니다.)

        // 그렇다면 현재 코드라인 상에서 빨간줄 뜨지도 않으니까 잘못 다운캐스팅이 이루어지는지에 대한
        // 확인이 불가능한 상황인데, 이를 해결하기 위한 것이 instanceof 연산자 입니다.

        System.out.println("animal4 검증 파트");
        if(animal4 instanceof  Dog) {
            Dog dog4 = (Dog) animal4;

            dog4.makeSound();
            dog4.fetch();
        }
        System.out.println("animal3는 다운캐스팅 안되는거 알앗으니까 검증 후에 다운캐스팅 시도해야겠네요");
        if(animal3 instanceof Dog) {
            Dog dog3 = (Dog) animal3;

            dog3.makeSound();
            dog3.fetch();
        }else {
            System.out.println("불가능한 다운캐스팅입니다.");
        }
    }
}

```

## 📄 AirConditioner.java

```java
package ch15_casting.centralcontrol;

public class AirConditioner implements Power{
    @Override
    public void on() {
        System.out.println("에어컨의 전원을 켭니다.");
    }

    @Override
    public void off() {
        System.out.println("에어컨의 전원을 끕니다.");
    }
}

```

## 📄 CentralControl.java

```java
package ch15_casting.centralcontrol;

public class CentralControl {
    // 필드 선언
    private Power[] deviceArray;

    public CentralControl(Power[] deviceArray) {
        this.deviceArray = deviceArray;
    }

    // 메서드 정의
    public void addDevice(Power device) {
        // 지금 우리는 Power의 자식 클래스에 해당하는 인스턴스들을
        // devicearray라는 필드에 추가하고 싶습니다.
        // 그러면 CentralControlMain에서 객체 생성을 할 때
        // deviceArray의 최종 indexNumber는 고정되게 되는데,
        // 다 들어차있는 배열에 덮어쓰기가 일어나서도 안되고(즉 기존 element를 삭제하면 안됨
        // 비어있는 element에 device 추가를 할 수 있어야 합니다.
        // 그렇다면 필요한 기능이 배열 내에 null 값이 존재하는지에 대한 체크가 필요하다고
        // 할수 있습니다.
        int emptyIndex = checkEmpty();  // method의 결과값을 변수 emptyIndex에 대임
        if(emptyIndex == -1) {
            System.out.println("더 이상 장치를 연결할 수 없습니다.");
            return;     // 메서드 종료 키워드
        }
        deviceArray[emptyIndex] = device;   // private으로 적용해놔서 method를 경유했습니다.
        // public이면 main에서 바로 위의 코드를 집어넣으면 되겠죠.
        System.out.println("장치가 연결되었습니다.");
    }

    private int checkEmpty() { // 메서드인데 private 썻습니다. Main에서 굳이
        // 몇 개나 더 전자제품을 추가할 수 있는지 알필요가 없을것같에서
        // deviceArray라는 배열에서 비어있는 index를 추출 해주기만 하면 되네요.
        // i++니까 가장 빨리 만나게 되는 null값을 return 하게 될겁니다.
        for(int i = 0; i < deviceArray.length; i++) {
            if(deviceArray[i] == null){
                return i;               // 즉 배열 내부에 element가 없다면 그 주소지를 return
            }
        }

        return -1;
    }
    /*
        Java의 index 넘버에는 음수 값이 없기 때문에 (python에서는 마이너스 인덱스 개념이 있는데 얘도
        시험에 자주 나옵니다), 실패를 나타낼 때 -1을 쓰는 경우가 많습니다.
        하지만 0과 너무 가까운 수이다보니 -100이든지, 아니면 return 값으로 나올 수 없으만한
        음수값을 지정하는 경우도 있는데,
        나중에 위에 있는 addDevice() 메서드에서 if(checkEmpty() == -89
     */
}


```

## 📄 CentralControlMain.java

```java
package ch15_casting.centralcontrol;

import ch06_condition.Condition01;

public class CentralControlMain {
    public static void main(String[] args) {
        // 각 클래스의 객체 생성
        Computer  computer1 = new Computer();
        AirConditioner airConditioner1 = new AirConditioner();
        Speaker speaker1 = new Speaker();
        // 참조자료형의 배열을 생성(비어있는거)
//        Power[] powers = new Power[5];
        // 이하의 코드는 powers 생성하면서 indexNumber가 고정되기 때문에 예시만 보여주고 안쓸겁니다.
//        Power[] powers = {new Computer(), new AirConditioner(), new Speaker()};

        CentralControl centralControl = new CentralControl(
                new Power[5]
        );

        centralControl.addDevice(computer1);                // 여기서 (암시적) 업케스팅이 이루어졋습니다.
        centralControl.addDevice(airConditioner1);
        centralControl.addDevice(speaker1);
        centralControl.addDevice(speaker1);
        centralControl.addDevice(speaker1);
        centralControl.addDevice(speaker1);


    }
}

```

## 📄 Computer.java

```java
package ch15_casting.centralcontrol;

public class Computer implements Power {

    @Override
    public void on() {
        System.out.println("컴퓨터의 전원을 켭니다.");
    }

    @Override
    public void off() {
        System.out.println("컴퓨터의 전원을 끕니다.");
    }
}
/*
    프로그램 구현 사항
    interface Power를 implement한 다향한 클래스드을 정의할 계정
    예을 들어 Computer / AirConditioner / Speaker들이 전부 Power를
    implenemt하게 되면 이상의 세 클래스들은 강제정으로
    on() / off() 매서드들을 override해야만 합니다.

    그대서 computer / AirConditioner / Speaker 객체들을
    전부 Power로 업캐스팅 시키게 된다면
    Computer / AirConditioner / Speaker 원래 클래스와 상관없이
    Power 클래스의 조작만으로 on() / off() 메서드를 호출시키는 것이 가능합니다.

    즉 B b = new B();로 에초에 객체를 생성하면 되지 않냐는 ㅓ아까가지의 의문은
    A의 자식 클래스가 B 하나뿐일대만 적용된다고 볼ㄹ 수 있습니다.
    a의 자식 클래스가 B C D E F .. 여랠 개가 있다고 가정한다면
    그것을 업캐스팅했을 대ㅑ A가 가지고 잇는 부모 메서드를 호출함으로써
    다수의 서로 다른 클래스의 객체들을 통제할 수 잇다는 장점 때문에
    업캐스팅을 적용하게 됩니다.
    그리고 다운캐스팅을 해서 각각 클래스의 고유 메서드도 실행시킬 수 있겠네요

    AirConditioner 클래스 생성해서 Power inplement하고
    에어컨의 전원을 켭니다.
    에어컨의 전원을 끕니다. 로 재정의하시오.
    speaker도 동일하게 하시오.
 */
```

## 📄 Power.java

```java
package ch15_casting.centralcontrol;

public interface Power {
    void on();

    void off();
}

```

## 📄 Speaker.java

```java
package ch15_casting.centralcontrol;

public class Speaker implements Power{
    @Override
    public void on() {
        System.out.println("스피커의 전원을 켭니다.");
    }

    @Override
    public void off() {
        System.out.println("스피커의 전원을 끕니다.");
    }
}



```

