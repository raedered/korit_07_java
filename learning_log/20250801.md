# For - Loop 예시
1. 구조
2.
```java
package ch07_loops;

public class Loop06 {
    public static void main(String[] args) {
        for( int i = 0 ; i < 6 ; i++ ) {
            for( int j = 0 ; j < i ; j++) {
                System.out.print("*");
            }
            System.out.println();
        }

        for (int i = 0 ; i < 5 ; i++) {
            for (int j = 5 ; j - i > 0 ; j--) {
                System.out.print("⭐");
            }
            System.out.println();
        }
        
        for (int i = 5 ; i > 0 ; i--) {
            for(int j = 0 ; j < i ; j++) {
                System.out.print("❤️");
            }
            System.out.println();
        }
        
        for(int i = 100 ; i > 0 ; i--) {
            System.out.println(i);
        }

    }
}
```
# return 값 유무와 관련된 보충입니다.

void -> return값이 존재하지 않는 경우
String / int / double으로 명시했을 경우 return 존재

```java
public void add1() {
   System.out.println("add()");
}

public String add2() {
    String result = "";
    
    result = "안녕하세요";
    
    return result;
}

public static void main(String[] args) {
   add1();           // 출력값 add()
   System.out.println(add1());
   
   add2();          // 콘솔에 출력이 되는가? -> x
   System.out.println(add2());      // 이게 비효율적으로 보인다.
   
   String hello = add2();       // return 타입을 명시하는 이유 중 하나는
                                // method의 결과를 변수에 저장하여
                                // 데이터를 가공해서 다른 메서드에 사용하기 위함

   System.out.println(hello + " ! ");
}

```

# 생성자 관련 정리(롬복)
1. NoArgsConsructor - 기본생성자
2. RequiredArgsConstructor - 매개변수 생성자
3. AllArgsConstructor - 클래스의 전체 필드를 요구하는 매개변수 생성자

method 구현 관련 정리 / 클래스 개념 - 구성 요소 / 생성자 관련 부분

# method

```java
public static void call1(){
        System.out.println("[ x | x ]");
        System.out.println("똑같은 말 수정 버전");
    }

    // 2. [ o | x ]
    public static void call2(String example) {
        System.out.println("[ o | x ]");
        System.out.println("영어 인사 : " + example);
    }

    public static String call3() {
        String example = "안녕하세요";
        System.out.println("[ x | o ]");
        return example;
    }

    // 3. [ o | o }
    public static double call4(double score) {
        System.out.println("[ o | o ]");
        System.out.println("해당 과목은 3학점짜리입니다.");
        return score * 3;
    }
```
return이 있는 이유는 기복적으로 데이터의 조작을 윟서
특정 매서드의 결과값이 다른 메서드의 argument로 사용가능함

함수형 프로그래밍(Functional Programming) :
메서드 1의 return 값이 ㅔㅁ서드2의 argument가 되고, 메서드2의 return값이
메서드 3의 argument가 되는 방식

첫 번째 메서드로부터 마지막 메서드까지의 흐름을 통해 프로그램이 이어지는 코딩 방식
```java
public static String introduce(String name, int age){
        return "제 이름은 " + name + "이고, 나이는 " + age + "살 입니다. \n내년에는 " + (age + 1) + "살이 됩니다.";
    }
```
## Method overloading
매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서
동일한 메서드 명을 지닌 메서드들의 정의 할 수 있다.

즉, 메서드명을 동일하고, 매개변수에 들어가는 자료형,, 갯수를
달리하게 되면 서로 다른 메서드로 받아들임.

### overloading의 장점
동일한 기능을 하는 메서드를 정의 할 때 메서드 명이 필요한데,
예를 들어 String 자료형끼리 연결해주는 메서드와
int끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때,
add,
plus,
connect등의 메서드를 정의 했다면
다음 합 연산을 하는(예를 들어 double 자료형을 지니는) 메서드 명을 정하는 것이 번거롭다

이러한 부분의 해결은
public void add(String example1, String example2) {
   로직
}

public void add(int example1, int example2) {
   로직
}
또는
public void add(String example1, String example2, String example3) {
   로직
}
와 같은 식으로 메서드 명을 동일하게 가져가면서 차이를 둘수 있고 머리가 아프지않다는 장점

```java
public class Overloading {
    // 메서드 정의 영역
    // call1() 유형
    public static void add() {
        System.out.println("add()");
    }

    // overloading 적용
    // call2() 유형으로 정의 #1
    public static void add(String s) {
        System.out.println("add(String s)");
        System.out.println(s);
    }

    // call2() 유형으로 작성 #2
    public static void add(int a, int b) {
        System.out.println("add(int a, int b)");    // 사실 얘랑
        System.out.println(a + b);                  // 얘는 overloading의 결과물이겠네요
    }

    public static void add(int a, String s) {
        System.out.println("add(int a, String s)");
        System.out.println(a + " / " + s);
    }

    public static void add(String s, int a) {
        System.out.println("add(Stirng s, int a)");
        System.out.println(a + " / " + s);
    }

    public static void add(int a, int b, double c) {
        System.out.println("add(int a, int b, double c");
        System.out.println("a + b + c = " + (a + b + c));
    }

    public static void main(String[] args) {
        // 메서드 호출 영역
        add();
        add("안녕하세요!");
        add(1, 2);
        add(8, "월 1일");
        add(1, 2, 4.5);
    }
}
```

# 클래스
## 글래스란?
객체를 생성하기 위한 설계도 = 틀 / 청사진.
현실 세계의 개념을 프로그래밍으로 표현할 때,
"특정 사물이나 개념의 틀직(속성)"과 "행위(메서드)"로 정의함.
예를 들어,
"자동차"라는 클래스를 생성한다면 자동차의 속성(색상, 속도)와,
해동(가속, 정지 등)을 코드로 표현할 수 있음.

## 객체(Object)란
클래스를 설계도로 가정했을 때, 실제 사용할 수 있는 자동차(인스턴스)는 객체라고 함.

여기서 Objext와 Instance라는 표현은 우리나라에서는 거의 동일함.

객체와 인스턴스의 관계
  객체는 포괄적인 개념으로 클래스에서 생성된 모든 것을 객체라고 표현,
  인스턴스는 특정 객체가 어떤 클래스의 구현체인지를 강조하는 표현

비유로 이해하기
  클래스 : 설계도
  객체 : 설계도를 바탕으로 만들어진 모든 실물
  

